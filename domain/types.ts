// # Windy Civi Type System
//
// This file defines the core type system for Windy Civi's event-sourced, graph-oriented feeds.
// The system is built around several key concepts:
//
// - **Nodes**: Base entities in our graph system
// - **Relations**: Connections between nodes
// - **Feeds**: A configuration for a list of Lists that gives users the ability to make many feeds
// - **Lists**: Immutable lists generated by Feeds
// - **Items**: The actual content, currently focused on legislation
//
// ## Core Graph Types

import { RepLevel, SupportedLocale } from "./constants";

// ### Base Node Interface
// The foundational type for all entities in our graph system.
export interface Node {
  id: string;
  created_at: string;
}

// ### Base Relation Interface
// Defines connections between nodes in our graph.
export interface Relation {
  id: string;
}

// ## Feed System
//
// ### Feed Types
// Feeds are the primary way users interact with content. They're dynamic
// collections that can be filtered and combined.

type FeedKey = string;

type Sorter = "UpdatedScore" | Prompt;

type FeedConfig = {
  sources: FeedKey[];
  matchers: {
    some?: Prompt[];
    all?: Prompt[];
  };
  sorters: Sorter[];
};

export interface Feed {
  key: FeedKey;
  config: FeedConfig;
  lists: ListKey[];
}

// ### List
// Lists represent immutable collections of items, providing a stable
// reference point for feed content.

// ListIDs always start with a timestamp to ensure they're unique.
type ListKey = string;

export interface List extends Node {
  key: ListKey;
  feedKey: FeedKey;
  config: FeedConfig; // immutable duplicate to see what it ran
  items: ListItem[]; // immutable duplicate of sorted results
}

export interface ListItem extends Relation {
  id: ItemID;
  tags: {
    [key: Prompt]: Ranking;
  };
}

type Ranking = true | false;

// ### Feed Relations
// Defines how items are related and scored within feeds.
export type FeedItemRelation = {
  id: string;
  score: {
    [key: Prompt]: Ranking;
  };
  relation: Relation;
};

type Prompt = string;

// ## Content Types
//
// ### Item Interface
// The core content type, currently specialized for legislation.

type ItemID = string;

export interface Item extends Node {
  id: ItemID;
  type: "WindyCiviLegislation";
  data: CiviLegislationData;
}

// ## User System
//
// ### User Types
// Defines user entities and their relationships with feeds.

type UserID = string;

export interface User {
  id: UserID;
  channels: {
    native: boolean;
  };
  subscriptions: {
    feeds: FeedKey[];
    items: ItemID[];
  }[];
}

// ## Legacy System Integration
//
// ### Legislation Types
// These types support integration with existing legislation data sources.

export type LegislationResult = {
  legislation: CiviLegislationData[];
  gpt: CiviGptLegislationData;
};

type CiviGptData = CiviGptLegislationData[keyof CiviGptLegislationData];

interface FilteredLegislationData {
  bill: CiviLegislationData;
  gpt?: CiviGptData;
  allTags: string[];
  level: RepLevel;
}

// ### Sponsor Information
export type Sponsor = {
  name: string;
  role: string;
  district: string;
};

// ### Core Legislation Data
// Represents the primary structure of legislation information.
export interface CiviLegislationData {
  status: string[];
  statusDate: string;
  id: string;
  title: string;
  link: string;
  url?: string;
  source_id: string;
  sponsors: Sponsor[];
  classification?: string;
  description?: string;
  tags?: string[];
  updated_at?: string;
  voteHistory?: { motion_classification: string[]; created_at: string }[];
  identifier?: string;
  bill_summary?: string;
  summaries?: {
    gpt: string;
  };
}

// ### Legislation Change Tracking
export type CiviLegislationDataForDiff = Partial<
  Pick<CiviLegislationData, "id" | "status" | "statusDate"> & {
    sponsors?: Partial<Sponsor>[];
  }
>;

export type LegislationChange = {
  id: string;
  differences: {
    added?: boolean;
    removed?: boolean;
    status?: { previous: string[] | null; new: string[] | null };
    statusDate?: { previous: string | null; new: string | null };
    sponsors?: {
      added: Partial<Sponsor>[] | null;
      removed: Partial<Sponsor>[] | null;
    };
  };
};

// ### GPT-Enhanced Data
export interface CiviGptLegislationData {
  [bill_id: string]: {
    gpt_summary: string;
    gpt_tags: string[];
  };
}

// ### Wiki Integration
export interface CiviWikiLegislationData {
  bill_id: string;
  summary: string;
  locale: string;
  date: string;
  tags: string[];
}

// ## Feed Processing Types

export type LegislationFeed = {
  fullLegislation: WindyCiviBill[];
  filteredLegislation: WindyCiviBill[];
};

export interface WindyCiviBill extends FilteredLegislationData {
  sponsoredByRep?: string | false;
}

// ## Data Access Layer

export interface DataStoreGetter {
  getLegislationData: (
    locale: SupportedLocale
  ) => Promise<CiviLegislationData[]>;
  getGptLegislation: (
    locale: SupportedLocale
  ) => Promise<CiviGptLegislationData>;
  locales: typeof SupportedLocale;
}

// ## Environment and Configuration

export type Env = {
  GOOGLE_API_KEY: string;
};

// ## Localization and Filtering

export type Locales = `${SupportedLocale}`;

export type LocationFilter = Locales | AddressFilter | Nullish;

export type AddressFilter = { address: string };

export type Nullish = undefined | "" | null;

export interface FilterParams {
  location: LocationFilter;
  tags: string[] | null;
  availableTags: string[];
  level: RepLevel | null;
}

export interface UserPreferences {
  filters: FilterParams;
}
